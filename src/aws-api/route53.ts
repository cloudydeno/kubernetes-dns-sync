// Autogenerated API client for: Amazon Route 53
// Generation parameters:
//   aws-sdk-js definitions from v2.1692.0
//   AWS service UID: route53-2013-04-01
//   code generation: v0.5
//   extra options:
//     "actions" = "ListHostedZones,ListResourceRecordSets,ChangeResourceRecordSets,GetChange"
//     "useImportMap" = "yes"
//   generated at: 2025-09-15
//   skipped 66 out of 70 actions, leaving 4
//
// Originally served at https://aws-api.deno.dev/v0.5/services/route53.ts?actions=ListHostedZones%2CListResourceRecordSets%2CChangeResourceRecordSets%2CGetChange&useImportMap=yes


import * as client from "@cloudydeno/aws-api/client/common.ts";
import * as cmnP from "@cloudydeno/aws-api/encoding/common.ts";
import * as xmlP from "@cloudydeno/aws-api/encoding/xml.ts";

export class Route53 {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Route53.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2013-04-01",
    "endpointPrefix": "route53",
    "globalEndpoint": "route53.amazonaws.com",
    "protocol": "rest-xml",
    "protocols": [
      "rest-xml"
    ],
    "serviceAbbreviation": "Route 53",
    "serviceFullName": "Amazon Route 53",
    "serviceId": "Route 53",
    "signatureVersion": "v4",
    "uid": "route53-2013-04-01",
    "auth": [
      "aws.auth#sigv4"
    ]
  };

  /** Creates, changes, or deletes a resource record set, which contains authoritative DNS information for a specified domain name or subdomain name. */
  async changeResourceRecordSets(
    params: ChangeResourceRecordSetsRequest,
    opts: client.RequestOptions = {},
  ): Promise<ChangeResourceRecordSetsResponse> {
    const body = xmlP.stringify({
      name: "ChangeResourceRecordSetsRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "ChangeBatch", ...ChangeBatch_Serialize(params["ChangeBatch"])},
      ]});
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ChangeResourceRecordSets",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/rrset/`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  /** Returns the current status of a change batch request. */
  async getChange(
    params: GetChangeRequest,
    opts: client.RequestOptions = {},
  ): Promise<GetChangeResponse> {

    const resp = await this.#client.performRequest({
      opts,
      action: "GetChange",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/change/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  /** Retrieves a list of the public and private hosted zones that are associated with the current Amazon Web Services account. */
  async listHostedZones(
    params: ListHostedZonesRequest = {},
    opts: client.RequestOptions = {},
  ): Promise<ListHostedZonesResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    if (params["DelegationSetId"] != null) query.set("delegationsetid", params["DelegationSetId"]?.toString() ?? "");
    if (params["HostedZoneType"] != null) query.set("hostedzonetype", params["HostedZoneType"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      opts, query,
      action: "ListHostedZones",
      method: "GET",
      requestUri: "/2013-04-01/hostedzone",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"Marker":true,"NextMarker":true},
      }),
      HostedZones: xml.getList("HostedZones", "HostedZone").map(HostedZone_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  /** Lists the resource record sets in a specified hosted zone. */
  async listResourceRecordSets(
    params: ListResourceRecordSetsRequest,
    opts: client.RequestOptions = {},
  ): Promise<ListResourceRecordSetsResponse> {
    const query = new URLSearchParams;
    if (params["StartRecordName"] != null) query.set("name", params["StartRecordName"]?.toString() ?? "");
    if (params["StartRecordType"] != null) query.set("type", params["StartRecordType"]?.toString() ?? "");
    if (params["StartRecordIdentifier"] != null) query.set("identifier", params["StartRecordIdentifier"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      opts, query,
      action: "ListResourceRecordSets",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/rrset`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"NextRecordName":true,"NextRecordIdentifier":true},
      }),
      ResourceRecordSets: xml.getList("ResourceRecordSets", "ResourceRecordSet").map(ResourceRecordSet_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
      NextRecordType: xml.first("NextRecordType", false, x => (x.content ?? '') as RRType),
    };
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForResourceRecordSetsChanged(
    params: GetChangeRequest,
    opts: client.RequestOptions = {},
  ): Promise<GetChangeResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ResourceRecordSetsChanged';
    for (let i = 0; i < 60; i++) {
      const resp = await this.getChange(params, opts);
      if (resp?.ChangeInfo?.Status === "INSYNC") return resp;
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
/** A complex type that contains change information for the resource record set. */
export interface ChangeResourceRecordSetsRequest {
  /** The ID of the hosted zone that contains the resource record sets that you want to change. */
  HostedZoneId: string;
  /** A complex type that contains an optional comment and the `Changes` element. */
  ChangeBatch: ChangeBatch;
}

// refs: 1 - tags: named, input
/** The input for a GetChange request. */
export interface GetChangeRequest {
  /** The ID of the change batch request. */
  Id: string;
}

// refs: 1 - tags: named, input
/** A request to retrieve a list of the public and private hosted zones that are associated with the current Amazon Web Services account. */
export interface ListHostedZonesRequest {
  /** If the value of `IsTruncated` in the previous response was `true`, you have more hosted zones. */
  Marker?: string | null;
  /** (Optional) The maximum number of hosted zones that you want Amazon Route 53 to return. */
  MaxItems?: string | null;
  /** If you're using reusable delegation sets and you want to list all of the hosted zones that are associated with a reusable delegation set, specify the ID of that reusable delegation set. */
  DelegationSetId?: string | null;
  /** (Optional) Specifies if the hosted zone is private. */
  HostedZoneType?: HostedZoneType | null;
}

// refs: 1 - tags: named, input
/** A request for the resource record sets that are associated with a specified hosted zone. */
export interface ListResourceRecordSetsRequest {
  /** The ID of the hosted zone that contains the resource record sets that you want to list. */
  HostedZoneId: string;
  /** The first name in the lexicographic ordering of resource record sets that you want to list. */
  StartRecordName?: string | null;
  /** The type of resource record set to begin the record listing from. */
  StartRecordType?: RRType | null;
  /** _Resource record sets that have a routing policy other than simple:_ If results were truncated for a given DNS name and type, specify the value of `NextRecordIdentifier` from the previous response to get the next resource record set that has the current DNS name and type. */
  StartRecordIdentifier?: string | null;
  /** (Optional) The maximum number of resource records sets to include in the response body for this request. */
  MaxItems?: string | null;
}

// refs: 1 - tags: named, output
/** A complex type containing the response for the request. */
export interface ChangeResourceRecordSetsResponse {
  /** A complex type that contains information about changes made to your hosted zone. */
  ChangeInfo: ChangeInfo;
}

// refs: 1 - tags: named, output
/** A complex type that contains the `ChangeInfo` element. */
export interface GetChangeResponse {
  /** A complex type that contains information about the specified change batch. */
  ChangeInfo: ChangeInfo;
}

// refs: 1 - tags: named, output
export interface ListHostedZonesResponse {
  /** A complex type that contains general information about the hosted zone. */
  HostedZones: HostedZone[];
  /** For the second and subsequent calls to `ListHostedZones`, `Marker` is the value that you specified for the `marker` parameter in the request that produced the current response. */
  Marker?: string | null;
  /** A flag indicating whether there are more hosted zones to be listed. */
  IsTruncated: boolean;
  /** If `IsTruncated` is `true`, the value of `NextMarker` identifies the first hosted zone in the next group of hosted zones. */
  NextMarker?: string | null;
  /** The value that you specified for the `maxitems` parameter in the call to `ListHostedZones` that produced the current response. */
  MaxItems: string;
}

// refs: 1 - tags: named, output
/** A complex type that contains list information for the resource record set. */
export interface ListResourceRecordSetsResponse {
  /** Information about multiple resource record sets. */
  ResourceRecordSets: ResourceRecordSet[];
  /** A flag that indicates whether more resource record sets remain to be listed. */
  IsTruncated: boolean;
  /** If the results were truncated, the name of the next record in the list. */
  NextRecordName?: string | null;
  /** If the results were truncated, the type of the next record in the list. */
  NextRecordType?: RRType | null;
  /** _Resource record sets that have a routing policy other than simple:_ If results were truncated for a given DNS name and type, the value of `SetIdentifier` for the next resource record set that has the current DNS name and type. */
  NextRecordIdentifier?: string | null;
  /** The maximum number of records you requested. */
  MaxItems: string;
}

// refs: 1 - tags: input, named, interface
/** The information for a change request. */
export interface ChangeBatch {
  /** _Optional:_ Any comments you want to include about a change batch request. */
  Comment?: string | null;
  /** Information about the changes to make to the record sets. */
  Changes: Change[];
}
function ChangeBatch_Serialize(data: ChangeBatch | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Changes", children: data["Changes"]?.map(x => ({name: "Change", ...Change_Serialize(x)}))},
  ]};
}

// refs: 1 - tags: input, named, interface
/** The information for each resource record set that you want to change. */
export interface Change {
  /** The action to perform: */
  Action: ChangeAction;
  /** Information about the resource record set to create, delete, or update. */
  ResourceRecordSet: ResourceRecordSet;
}
function Change_Serialize(data: Change | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Action", content: data["Action"]?.toString()},
    {name: "ResourceRecordSet", ...ResourceRecordSet_Serialize(data["ResourceRecordSet"])},
  ]};
}

// refs: 1 - tags: input, named, enum
export type ChangeAction =
| "CREATE"
| "DELETE"
| "UPSERT"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
/** Information about the resource record set to create or delete. */
export interface ResourceRecordSet {
  /** For `ChangeResourceRecordSets` requests, the name of the record that you want to create, update, or delete. */
  Name: string;
  /** The DNS record type. */
  Type: RRType;
  /** _Resource record sets that have a routing policy other than simple:_ An identifier that differentiates among multiple resource record sets that have the same combination of name and type, such as multiple weighted resource record sets named acme.example.com that have a type of A. */
  SetIdentifier?: string | null;
  /** _Weighted resource record sets only:_ Among resource record sets that have the same combination of DNS name and type, a value that determines the proportion of DNS queries that Amazon Route 53 responds to using the current resource record set. */
  Weight?: number | null;
  /** _Latency-based resource record sets only:_ The Amazon EC2 Region where you created the resource that this resource record set refers to. */
  Region?: ResourceRecordSetRegion | null;
  /** _Geolocation resource record sets only:_ A complex type that lets you control how Amazon Route 53 responds to DNS queries based on the geographic origin of the query. */
  GeoLocation?: GeoLocation | null;
  /** _Failover resource record sets only:_ To configure failover, you add the `Failover` element to two resource record sets. */
  Failover?: ResourceRecordSetFailover | null;
  /** _Multivalue answer resource record sets only_: To route traffic approximately randomly to multiple resources, such as web servers, create one multivalue answer record for each resource and specify `true` for `MultiValueAnswer`. */
  MultiValueAnswer?: boolean | null;
  /** The resource record cache time to live (TTL), in seconds. */
  TTL?: number | null;
  /** Information about the resource records to act upon. */
  ResourceRecords?: ResourceRecord[] | null;
  /** _Alias resource record sets only:_ Information about the Amazon Web Services resource, such as a CloudFront distribution or an Amazon S3 bucket, that you want to route traffic to. */
  AliasTarget?: AliasTarget | null;
  /** If you want Amazon Route 53 to return this resource record set in response to a DNS query only when the status of a health check is healthy, include the `HealthCheckId` element and specify the ID of the applicable health check. */
  HealthCheckId?: string | null;
  /** When you create a traffic policy instance, Amazon Route 53 automatically creates a resource record set. */
  TrafficPolicyInstanceId?: string | null;
  CidrRoutingConfig?: CidrRoutingConfig | null;
  /** _GeoproximityLocation resource record sets only:_ A complex type that lets you control how Route 53 responds to DNS queries based on the geographic origin of the query and your resources. */
  GeoProximityLocation?: GeoProximityLocation | null;
}
function ResourceRecordSet_Serialize(data: ResourceRecordSet | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Name", content: data["Name"]?.toString()},
    {name: "Type", content: data["Type"]?.toString()},
    {name: "SetIdentifier", content: data["SetIdentifier"]?.toString()},
    {name: "Weight", content: data["Weight"]?.toString()},
    {name: "Region", content: data["Region"]?.toString()},
    {name: "GeoLocation", ...GeoLocation_Serialize(data["GeoLocation"])},
    {name: "Failover", content: data["Failover"]?.toString()},
    {name: "MultiValueAnswer", content: data["MultiValueAnswer"]?.toString()},
    {name: "TTL", content: data["TTL"]?.toString()},
    {name: "ResourceRecords", children: data["ResourceRecords"]?.map(x => ({name: "ResourceRecord", ...ResourceRecord_Serialize(x)}))},
    {name: "AliasTarget", ...AliasTarget_Serialize(data["AliasTarget"])},
    {name: "HealthCheckId", content: data["HealthCheckId"]?.toString()},
    {name: "TrafficPolicyInstanceId", content: data["TrafficPolicyInstanceId"]?.toString()},
    {name: "CidrRoutingConfig", ...CidrRoutingConfig_Serialize(data["CidrRoutingConfig"])},
    {name: "GeoProximityLocation", ...GeoProximityLocation_Serialize(data["GeoProximityLocation"])},
  ]};
}
function ResourceRecordSet_Parse(node: xmlP.XmlNode): ResourceRecordSet {
  return {
    ...node.strings({
      required: {"Name":true},
      optional: {"SetIdentifier":true,"HealthCheckId":true,"TrafficPolicyInstanceId":true},
    }),
    Type: node.first("Type", true, x => (x.content ?? '') as RRType),
    Weight: node.first("Weight", false, x => parseInt(x.content ?? '0')),
    Region: node.first("Region", false, x => (x.content ?? '') as ResourceRecordSetRegion),
    GeoLocation: node.first("GeoLocation", false, GeoLocation_Parse),
    Failover: node.first("Failover", false, x => (x.content ?? '') as ResourceRecordSetFailover),
    MultiValueAnswer: node.first("MultiValueAnswer", false, x => x.content === 'true'),
    TTL: node.first("TTL", false, x => parseInt(x.content ?? '0')),
    ResourceRecords: node.getList("ResourceRecords", "ResourceRecord").map(ResourceRecord_Parse),
    AliasTarget: node.first("AliasTarget", false, AliasTarget_Parse),
    CidrRoutingConfig: node.first("CidrRoutingConfig", false, CidrRoutingConfig_Parse),
    GeoProximityLocation: node.first("GeoProximityLocation", false, GeoProximityLocation_Parse),
  };
}

// refs: 4 - tags: input, named, enum, output
export type RRType =
| "SOA"
| "A"
| "TXT"
| "NS"
| "CNAME"
| "MX"
| "NAPTR"
| "PTR"
| "SRV"
| "SPF"
| "AAAA"
| "CAA"
| "DS"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type ResourceRecordSetRegion =
| "us-east-1"
| "us-east-2"
| "us-west-1"
| "us-west-2"
| "ca-central-1"
| "eu-west-1"
| "eu-west-2"
| "eu-west-3"
| "eu-central-1"
| "eu-central-2"
| "ap-southeast-1"
| "ap-southeast-2"
| "ap-southeast-3"
| "ap-northeast-1"
| "ap-northeast-2"
| "ap-northeast-3"
| "eu-north-1"
| "sa-east-1"
| "cn-north-1"
| "cn-northwest-1"
| "ap-east-1"
| "me-south-1"
| "me-central-1"
| "ap-south-1"
| "ap-south-2"
| "af-south-1"
| "eu-south-1"
| "eu-south-2"
| "ap-southeast-4"
| "il-central-1"
| "ca-west-1"
| "ap-southeast-5"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
/** A complex type that contains information about a geographic location. */
export interface GeoLocation {
  /** The two-letter code for the continent. */
  ContinentCode?: string | null;
  /** For geolocation resource record sets, the two-letter code for a country. */
  CountryCode?: string | null;
  /** For geolocation resource record sets, the two-letter code for a state of the United States. */
  SubdivisionCode?: string | null;
}
function GeoLocation_Serialize(data: GeoLocation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ContinentCode", content: data["ContinentCode"]?.toString()},
    {name: "CountryCode", content: data["CountryCode"]?.toString()},
    {name: "SubdivisionCode", content: data["SubdivisionCode"]?.toString()},
  ]};
}
function GeoLocation_Parse(node: xmlP.XmlNode): GeoLocation {
  return node.strings({
    optional: {"ContinentCode":true,"CountryCode":true,"SubdivisionCode":true},
  });
}

// refs: 2 - tags: input, named, enum, output
export type ResourceRecordSetFailover =
| "PRIMARY"
| "SECONDARY"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
/** Information specific to the resource record. */
export interface ResourceRecord {
  /** The current or new DNS record value, not to exceed 4,000 characters. */
  Value: string;
}
function ResourceRecord_Serialize(data: ResourceRecord | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function ResourceRecord_Parse(node: xmlP.XmlNode): ResourceRecord {
  return node.strings({
    required: {"Value":true},
  });
}

// refs: 2 - tags: input, named, interface, output
/** _Alias resource record sets only:_ Information about the Amazon Web Services resource, such as a CloudFront distribution or an Amazon S3 bucket, that you want to route traffic to. */
export interface AliasTarget {
  /** _Alias resource records sets only_: The value used depends on where you want to route traffic: */
  HostedZoneId: string;
  /** _Alias resource record sets only:_ The value that you specify depends on where you want to route queries: */
  DNSName: string;
  /** _Applies only to alias, failover alias, geolocation alias, latency alias, and weighted alias resource record sets:_ When `EvaluateTargetHealth` is `true`, an alias resource record set inherits the health of the referenced Amazon Web Services resource, such as an ELB load balancer or another resource record set in the hosted zone. */
  EvaluateTargetHealth: boolean;
}
function AliasTarget_Serialize(data: AliasTarget | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HostedZoneId", content: data["HostedZoneId"]?.toString()},
    {name: "DNSName", content: data["DNSName"]?.toString()},
    {name: "EvaluateTargetHealth", content: data["EvaluateTargetHealth"]?.toString()},
  ]};
}
function AliasTarget_Parse(node: xmlP.XmlNode): AliasTarget {
  return {
    ...node.strings({
      required: {"HostedZoneId":true,"DNSName":true},
    }),
    EvaluateTargetHealth: node.first("EvaluateTargetHealth", true, x => x.content === 'true'),
  };
}

// refs: 2 - tags: input, named, interface, output
/** The object that is specified in resource record set object when you are linking a resource record set to a CIDR location. */
export interface CidrRoutingConfig {
  /** The CIDR collection ID. */
  CollectionId: string;
  /** The CIDR collection location name. */
  LocationName: string;
}
function CidrRoutingConfig_Serialize(data: CidrRoutingConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CollectionId", content: data["CollectionId"]?.toString()},
    {name: "LocationName", content: data["LocationName"]?.toString()},
  ]};
}
function CidrRoutingConfig_Parse(node: xmlP.XmlNode): CidrRoutingConfig {
  return node.strings({
    required: {"CollectionId":true,"LocationName":true},
  });
}

// refs: 2 - tags: input, named, interface, output
/** (Resource record sets only): A complex type that lets you specify where your resources are located. */
export interface GeoProximityLocation {
  /** The Amazon Web Services Region the resource you are directing DNS traffic to, is in. */
  AWSRegion?: string | null;
  /** Specifies an Amazon Web Services Local Zone Group. */
  LocalZoneGroup?: string | null;
  /** Contains the longitude and latitude for a geographic region. */
  Coordinates?: Coordinates | null;
  /** The bias increases or decreases the size of the geographic region from which Route 53 routes traffic to a resource. */
  Bias?: number | null;
}
function GeoProximityLocation_Serialize(data: GeoProximityLocation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "AWSRegion", content: data["AWSRegion"]?.toString()},
    {name: "LocalZoneGroup", content: data["LocalZoneGroup"]?.toString()},
    {name: "Coordinates", ...Coordinates_Serialize(data["Coordinates"])},
    {name: "Bias", content: data["Bias"]?.toString()},
  ]};
}
function GeoProximityLocation_Parse(node: xmlP.XmlNode): GeoProximityLocation {
  return {
    ...node.strings({
      optional: {"AWSRegion":true,"LocalZoneGroup":true},
    }),
    Coordinates: node.first("Coordinates", false, Coordinates_Parse),
    Bias: node.first("Bias", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: input, named, interface, output
/** A complex type that lists the coordinates for a geoproximity resource record. */
export interface Coordinates {
  /** Specifies a coordinate of the north–south position of a geographic point on the surface of the Earth (-90 - 90). */
  Latitude: string;
  /** Specifies a coordinate of the east–west position of a geographic point on the surface of the Earth (-180 - 180). */
  Longitude: string;
}
function Coordinates_Serialize(data: Coordinates | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Latitude", content: data["Latitude"]?.toString()},
    {name: "Longitude", content: data["Longitude"]?.toString()},
  ]};
}
function Coordinates_Parse(node: xmlP.XmlNode): Coordinates {
  return node.strings({
    required: {"Latitude":true,"Longitude":true},
  });
}

// refs: 1 - tags: input, named, enum
export type HostedZoneType =
| "PrivateHostedZone"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
/** A complex type that describes change information about changes made to your hosted zone. */
export interface ChangeInfo {
  /** This element contains an ID that you use when performing a [GetChange](https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetChange.html) action to get detailed information about the change. */
  Id: string;
  /** The current state of the request. */
  Status: ChangeStatus;
  /** The date and time that the change request was submitted in [ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601) and Coordinated Universal Time (UTC). */
  SubmittedAt: Date | number;
  /** A comment you can provide. */
  Comment?: string | null;
}
function ChangeInfo_Parse(node: xmlP.XmlNode): ChangeInfo {
  return {
    ...node.strings({
      required: {"Id":true},
      optional: {"Comment":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as ChangeStatus),
    SubmittedAt: node.first("SubmittedAt", true, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, enum
export type ChangeStatus =
| "PENDING"
| "INSYNC"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
/** A complex type that contains general information about the hosted zone. */
export interface HostedZone {
  /** The ID that Amazon Route 53 assigned to the hosted zone when you created it. */
  Id: string;
  /** The name of the domain. */
  Name: string;
  /** The value that you specified for `CallerReference` when you created the hosted zone. */
  CallerReference: string;
  /** A complex type that includes the `Comment` and `PrivateZone` elements. */
  Config?: HostedZoneConfig | null;
  /** The number of resource record sets in the hosted zone. */
  ResourceRecordSetCount?: number | null;
  /** If the hosted zone was created by another service, the service that created the hosted zone. */
  LinkedService?: LinkedService | null;
}
function HostedZone_Parse(node: xmlP.XmlNode): HostedZone {
  return {
    ...node.strings({
      required: {"Id":true,"Name":true,"CallerReference":true},
    }),
    Config: node.first("Config", false, HostedZoneConfig_Parse),
    ResourceRecordSetCount: node.first("ResourceRecordSetCount", false, x => parseInt(x.content ?? '0')),
    LinkedService: node.first("LinkedService", false, LinkedService_Parse),
  };
}

// refs: 1 - tags: output, named, interface
/** A complex type that contains an optional comment about your hosted zone. */
export interface HostedZoneConfig {
  /** Any comments that you want to include about the hosted zone. */
  Comment?: string | null;
  /** A value that indicates whether this is a private hosted zone. */
  PrivateZone?: boolean | null;
}
function HostedZoneConfig_Parse(node: xmlP.XmlNode): HostedZoneConfig {
  return {
    ...node.strings({
      optional: {"Comment":true},
    }),
    PrivateZone: node.first("PrivateZone", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
/** If a health check or hosted zone was created by another service, `LinkedService` is a complex type that describes the service that created the resource. */
export interface LinkedService {
  /** If the health check or hosted zone was created by another service, the service that created the resource. */
  ServicePrincipal?: string | null;
  /** If the health check or hosted zone was created by another service, an optional description that can be provided by the other service. */
  Description?: string | null;
}
function LinkedService_Parse(node: xmlP.XmlNode): LinkedService {
  return node.strings({
    optional: {"ServicePrincipal":true,"Description":true},
  });
}
